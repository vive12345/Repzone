# -*- coding: utf-8 -*-
"""Osmnx_Distance_Matrix_Code_According_to_District_and_City_Sachin.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_pCjy3UtnuM0hgVXkY_2fxoPfvr-Anfu
"""

!pip install osmnx
!pip install ortools

import pandas as pd
import numpy as np
import osmnx as ox
import networkx as nx
import folium
from ortools.constraint_solver import pywrapcp
from ortools.constraint_solver import routing_enums_pb2

# Load the "Customer" sheet and rename the VisitFreq column
df = pd.read_excel('/content/Omdena_Repzone_v1.xlsx', sheet_name="Customer")
df = df.rename(columns={
    'VisitFreq \n(1: Every Week, \n2: Every 2 Weeks, \n3: Everey 3 Weeks, \n4: Every 4 Weeks)': 'VisitFreq'
})

# Preprocess the coordinates
def convert_coordinates(df):
    """
    Converts 'Longitude' and 'Latitude' columns to numeric, handling comma as decimal if the dtype is not float.
    """
    cols_to_check = ['Longitude', 'Latitude']
    for col in cols_to_check:
        if col in df.columns and df[col].dtype != float:
            # Check if there are any non-numeric values containing comma
            non_numeric_with_comma = df[pd.to_numeric(df[col], errors='coerce').isna()][col].astype(str).str.contains(',').any()
            if non_numeric_with_comma:
                df[col] = df[col].str.replace(',', '.', regex=False)
            df[col] = pd.to_numeric(df[col], errors='coerce')
    return df

df = convert_coordinates(df)

# Optional: Store any errors in travel time calculations
error_log = []

def get_distance_matrix(city_name, district_name):
    """
    Calculate the distance matrix for a given city and district.

    Parameters:
    - city_name (str): Name of the city (e.g., "İstanbul")
    - district_name (str): Name of the district (e.g., "Şişli")

    Returns:
    - distance_matrix (pd.DataFrame): Travel time matrix between locations
    - map (folium.Map): Interactive map with locations plotted
    """

    # Filter data for the specified city and district
    df_city = df[df["City"] == city_name]
    if df_city.empty:
        raise ValueError(f"No data found for city: {city_name}")

    df_district = df_city[df_city["District"] == district_name]
    if df_district.empty:
        raise ValueError(f"No data found for district: {district_name} in city: {city_name}")

    # Extract coordinates and reset index
    dis = df_district[["Latitude", "Longitude"]].reset_index(drop=True)
    dis = dis.reset_index().rename(columns={"index": "id", "Latitude": "y", "Longitude": "x"})

    # Drop rows with missing coordinates
    dis = dis.dropna(subset=["y", "x"])
    if dis.empty:
        raise ValueError(f"No valid coordinates found for {district_name}, {city_name}")

    # Prepare data for visualization
    data = dis.copy()
    data["color"] = ''
    data.loc[data.index[0], 'color'] = 'red'  # Starting point
    data.loc[data.index[1:], 'color'] = 'black'  # Other points
    start = data.iloc[0, [data.columns.get_loc("y"), data.columns.get_loc("x")]].values

    # Create Folium map
    folium_map = folium.Map(location=start, zoom_start=12)
    data.apply(lambda row: folium.CircleMarker(
        location=[row["y"], row["x"]],
        color=row["color"], fill=True, radius=5, popup=row.name
    ).add_to(folium_map), axis=1)

    # Download road network from OpenStreetMap
    graph = ox.graph_from_point(start, dist=10000, network_type="drive")
    graph = ox.add_edge_speeds(graph)
    graph = ox.add_edge_travel_times(graph)

    # Map locations to nearest nodes in the graph
    dis["node"] = dis[["y", "x"]].apply(
        lambda x: ox.distance.nearest_nodes(graph, x.iloc[1], x.iloc[0]), axis=1
    )
    dis = dis.drop_duplicates("node", keep='first')

    # Define function to calculate travel time between nodes
    def calculate_travel_time(a, b):
        try:
            return nx.shortest_path_length(graph, source=a, target=b, method='dijkstra', weight='travel_time')
        except Exception as e:
            error_msg = f"[ERROR] Failed to calculate travel time between nodes {a} and {b}: {e}"
            print(error_msg)
            error_log.append(error_msg)
            return np.nan

    # Compute distance matrix
    nodes = dis["node"].tolist()
    distance_matrix = np.asarray([[calculate_travel_time(a, b) for b in nodes] for a in nodes])
    distance_matrix = pd.DataFrame(distance_matrix, columns=nodes, index=nodes)

    # Clean and format the distance matrix
    distance_matrix.dropna(axis=1, inplace=True)
    distance_matrix.dropna(axis=0, inplace=True)
    distance_matrix = distance_matrix.round().astype(int)

    return distance_matrix, folium_map

# Example usage
try:
    city = input("Enter the city name (e.g., İstanbul): ")
    district = input("Enter the district name (e.g., Şişli): ")
    dist_matrix, folium_map = get_distance_matrix(city, district)

    print(f"\nDistance Matrix for {district}, {city}:")
    print(dist_matrix)
    print("\nDisplaying the map...")
    display(folium_map)  # Use this in Jupyter/Colab; otherwise, save it as HTML

except ValueError as e:
    print(f"Error: {e}")
except Exception as e:
    print(f"An unexpected error occurred: {e}")

# Optional: Display the first 5 rows of the DataFrame
print("Distance Matrix:")
dist_matrix