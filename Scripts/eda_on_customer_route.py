# -*- coding: utf-8 -*-
"""EDA_on_customer_route.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m6X7pIjtCpuRUdyD43cTGdfhOtyWn21g
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import skew

df=pd.read_csv('Customer_route.csv')

df.describe()

df.info()

df.columns

"""# **Checking for Redundant Columns in a DataFrame**
- **`RouteFrequency`** (which represents visit frequency in a structured format)  
- **`VisitFreq`** (which may contain the same information)  

contain duplicate values.



"""

mismatch_count = (df['RouteFrequency\n(1: Every Week, \n2: Every 2 Weeks, \n3: Everey 3 Weeks, \n4: Every 4 Weeks)'] != df['VisitFreq']).sum()

print(f"Number of mismatches: {mismatch_count}")
df=df.drop(columns='RouteFrequency\n(1: Every Week, \n2: Every 2 Weeks, \n3: Everey 3 Weeks, \n4: Every 4 Weeks)')

"""# **ðŸ“Š Frequency of Visits on Each Day of the Week**
Analyzing which **day of the week** has the highest number of visits can help in **route optimization** and **resource allocation**. This can be done by extracting the **day of the week** from the visit dates and then counting visits per day.

"""

Frequency_of_visit_each_day_in_week=df['RouteDayOfTheWeek\n(Mon, Tue, Wed, Thu, Fri, Sat, Sun)'].value_counts()
plt.bar(Frequency_of_visit_each_day_in_week.index,Frequency_of_visit_each_day_in_week.values)
plt.xlabel('week')
plt.ylabel('Frequency of Visit')
plt.title('Frequency of visit each day in week')

"""# **ðŸ“Š Distribution of Visit Frequencies**
This analysis visualizes how frequently visits occur, helping to identify patterns in visit scheduling.

---



"""

# Count the frequency of each unique value in 'VisitFreq'
visit_counts = df['VisitFreq'].value_counts()

plt.figure(figsize=(12, 6))  # Adjust figure size
sns.barplot(x=visit_counts.index, y=visit_counts.values, palette='coolwarm')

plt.xlabel('Visit Frequency', fontsize=14)
plt.ylabel('Count', fontsize=14)
plt.title('Distribution of Visit Frequencies', fontsize=18)

plt.xticks(rotation=45, ha='right', fontsize=12)  # Rotate labels for better readability
plt.yticks(fontsize=12)

plt.show()

"""# **ðŸ“Š Number of Representatives per Region**
This analysis calculates the **total number of unique representatives** assigned to each region and sorts the results in **descending order** to identify the regions with the most representatives.

---



"""

No_of_Representative_per_region = df.groupby('region')['RouteRepresentativeId'].nunique() \
    .reset_index(name='TotalRepresentatives') \
    .sort_values(by='TotalRepresentatives', ascending=False)  # Change to True for ascending

print(No_of_Representative_per_region)

plt.figure(figsize=(12, 6))  # Increase figure size

sns.barplot(data=No_of_Representative_per_region, x='region', y='TotalRepresentatives', palette='coolwarm')

plt.xlabel('Region', fontsize=14)
plt.ylabel('Total Representatives', fontsize=14)
plt.title('Number of Representatives Per Region', fontsize=18)

plt.xticks(rotation=45,ha='right',fontsize=12)
plt.yticks(fontsize=12)

plt.show()

"""# **ðŸ“Š Number of Representatives per City**
This analysis determines the **total number of unique representatives** assigned to each city.  
To avoid inconsistencies due to different capitalizations and extra spaces, we first **normalize city names** before grouping and visualizing the data.
We can see the  High Demand Cities

---


"""

# Create a new variable for lowercase city names without modifying df
city_lower_case = df['City'].str.lower().str.strip()

# Create a temporary DataFrame for grouping
temp_df = df.copy()
temp_df['City'] = city_lower_case  # Use the lowercase version for grouping

# Group by the normalized city names and count unique representatives
No_of_Representative_per_city = temp_df.groupby('City')['RouteRepresentativeId'].nunique().reset_index(name='TotalRepresentatives')

# Sort in descending order
No_of_Representative_per_city = No_of_Representative_per_city.sort_values(by='TotalRepresentatives', ascending=False)

# Plot the bar chart
plt.figure(figsize=(18, 8))  # Increase figure size

sns.barplot(data=No_of_Representative_per_city, x='City', y='TotalRepresentatives', palette='viridis')

plt.xlabel('City', fontsize=14)
plt.ylabel('Total Representatives', fontsize=14)
plt.title('Number of Representatives Per City', fontsize=18)

plt.xticks(rotation=45, ha='right', fontsize=10)  # Rotate & reduce font size
plt.yticks(fontsize=10)

plt.tight_layout()  # Adjust spacing to fit everything
plt.show()

"""# **ðŸ“Š Visit Frequency Analysis Per Day**
This analysis examines the **number of visits made by each representative on different days**. The data is visualized using a **heatmap** to identify patterns in visit frequency.
We can see that their are outlier 10,9,8.



"""

No_of_visit_count_per_day=df.groupby(['RouteDay', 'RouteRepresentativeId']).size().reset_index(name='VisitCount')

No_of_visit_count_per_day.VisitCount.describe()

pivot_table = No_of_visit_count_per_day.pivot(index='RouteRepresentativeId', columns='RouteDay', values='VisitCount').fillna(0)

plt.figure(figsize=(12, 6))
sns.heatmap(pivot_table, cmap="coolwarm", annot=True, fmt=".0f", linewidths=0.5)

plt.xlabel('Date')
plt.ylabel('Representative ID')
plt.title('Visit Frequency Heatmap')
plt.show()

plt.figure(figsize=(10, 5))
sns.histplot(No_of_visit_count_per_day['VisitCount'], bins=30, kde=True, color='blue')

plt.xlabel('Number of Visits')
plt.ylabel('Frequency')
plt.title('Distribution of Visit Counts')
plt.show()

plt.figure(figsize=(8, 4))
sns.boxplot(x=No_of_visit_count_per_day['VisitCount'], color='orange')

plt.xlabel('Number of Visits')
plt.title('Box Plot of Visit Counts')
plt.show()

plt.figure(figsize=(8, 4))
sns.violinplot(x=No_of_visit_count_per_day['VisitCount'], color='green')

plt.xlabel('Number of Visits')
plt.title('Violin Plot of Visit Counts')
plt.show()

"""From the above plot we can see that the visit_count is right--skewed ,thier may be a problem of vanishing gradient problem for deep learning Models

"""

skewness = skew(No_of_visit_count_per_day['VisitCount'])
print(f"Skewness: {skewness:.2f}")  # Positive value confirms right skew

"""# **ðŸ“Š Checking data for any seasonality visit**"""

import matplotlib.pyplot as plt
import seaborn as sns

# Convert RouteDay to datetime format
No_of_visit_count_per_day['RouteDay'] = pd.to_datetime(No_of_visit_count_per_day['RouteDay'])

# Extract weekly periods and month names
No_of_visit_count_per_day['Week'] = No_of_visit_count_per_day['RouteDay'].dt.to_period('W')  # Weekly grouping
No_of_visit_count_per_day['Month'] = No_of_visit_count_per_day['RouteDay'].dt.strftime('%B')  # Extract month name

# Aggregate visits per week
weekly_visits = No_of_visit_count_per_day.groupby(['Month', 'Week'])['VisitCount'].sum().reset_index()

# Convert 'Week' to string format but ensure proper datetime sorting
weekly_visits['WeekStartDate'] = weekly_visits['Week'].apply(lambda x: x.start_time)  # Get start date of the week

# Sort the DataFrame by actual week start dates
weekly_visits = weekly_visits.sort_values(by='WeekStartDate')

# Assign formatted labels: "Month - 1st Week", "Month - 2nd Week", etc.
weekly_visits['WeekLabel'] = [
    f"{row.Month} - {i+1}{'st' if i+1 == 1 else 'nd' if i+1 == 2 else 'rd' if i+1 == 3 else 'th'} Week"
    for i, row in enumerate(weekly_visits.itertuples(index=False))
]

# Plot the weekly time series
plt.figure(figsize=(15, 6))
sns.lineplot(data=weekly_visits, x='WeekLabel', y='VisitCount', marker='o', linewidth=2, color='b')

plt.xlabel('Month - Week', fontsize=14)
plt.ylabel('Total Visits', fontsize=14)
plt.title('Weekly Visit Count Over Time (Seasonality Check)', fontsize=18)

plt.xticks(rotation=45, ha='right')  # Rotate for readability
plt.grid(True)
plt.show()



